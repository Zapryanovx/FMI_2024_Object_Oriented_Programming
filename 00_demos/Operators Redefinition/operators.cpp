#include <iostream>

struct A
{
	int a1 = 0;
	int a2 = 0;

public:
	A(int a1, int a2) : a1(a1), a2(a2)
	{
		;
	}

	void printAll() const
	{
		std::cout << a1 << " " << a2 << std::endl;
	}

	A& operator+=(const A& other);


	friend std::ostream& operator<<(std::ostream& os, const A& obj); //за да се придържаме към стандартния синтаксис
	                                                                 //ще изнесем operator<< във външна функция, за да избегнем
	                                                                 //скришното подаване на [this], което се извършва във всички
	                                                                 //вътрешни функции

	                                                                 //то тогава ще имаме параметри (<поток>, <обект>),
	                                                                 //за разлика от вътрешната функция, която показахме

																	 //за да достъпим член-данните на обекта (които са private/protected)
																	 //във външната функция, ще кажем, 
	                                                                 //че тя е friend (приятелска за обекта)

	friend std::istream& operator>>(std::istream& is, A& obj); //за да се придържаме към стандартния синтаксис

	A& operator++(); //променяме обекта => вътрешни
	A operator++(int);

};

A& A::operator+=(const A& other) //операторът [+=] ще симулира действието на прибавянето на стойностите на член-данните
								 //на десния обект към левия, тоест ЩЕ СЕ промени левия => по уговорка ВЪТРЕШНА функция 
{   //добавяме стойностите
	//на втория обект към първия

	this->a1 += other.a1;        //връщането по референция ни позволява така нареченото chain-ване на оператори, т.е.
	this->a2 += other.a2;        //ако имаме три обекта от тип [A] -> [first], [second], [third], то става валиден 
	                             //синтаксиса [first] += [second] += [third]
								 
								 //напомняме, че ако връщаме по копие, chain-ването също е възможно,
	                             //но връщаме по референция с цел да направим кода си по-ефективен
	return *this;
}

A operator+(const A& first, const A& second) //операторът [+] ще симулира действието събиране между два обекта,
{											 //тоест НЯМА ДА СЕ промени левия => по уговорка ВЪНШНА функция 
	//тъй като вече сме предефиниларли
	//оператора [+=] можем да го преизползваме

	//създаваме третия обект, който ще връщаме
	//директо чрез копиращия конструктор
	//(така данните му ще вземат стойностите на един от тях)

	A res(first);							 //напомняме, че при ВЪНШНО-предефинираните оператори, ще връщаме ПО КОПИЕ,
											 //тъй като във функцията създаваме трети обект, който да върнем, т.е.
	//преизползваме [+=]					 //локален за функцията обект => ще се изтрие след скоупа на функцията =>
	//(променяме левия и му добавяме		 //ако върнем по референция, ще имаме референция към вече несъществуващ обект,
	//стойностите на десния)				 //което ще доведе до [UB]
	res += second;                          
									         						
	return res;								
}

bool operator==(const A& first, const A& second) //левия не се променя => ВЪНШНА ФУНКЦИЯ
{												 //при предефиниране на operator== е прието да
	//примерен стандарт за еквивалентност        //връщаме тип [bool], тъй като операторът не е предназначен за
	return first.a1 == second.a1                 //chain-ване => трябва просто да върнем [true], ако два обекта са 
		&& first.a2 == second.a2;                //еквивалентни по даден стандарт и [false], ако не са
}

std::ostream& operator<<(std::ostream& ofs, const A& obj) //връщаме по референция по аналогични причини на [+=]
{														  //(по-ефективно chain-ване)                                
												
											   //не подаваме тайно [this], т.е. се придържаме към
	                                           //синтаксиса, на който сме свикнали
	                                         

	return ofs << obj.a1 << " " << obj.a2; //връщаме потока след като запазим в него [a1], [a2]
}

std::istream& operator>>(std::istream& is,  A& obj) //[NOTE] : забелязваме, че потоците, които връщаме и подаваме са
{													//ostream и istream (това е така, защото НЕ работим с файлове,
												    //а с всякакви потоци (поддържащи вход/изход)
	return is >> obj.a1 >> obj.a2;
}

//забелязваме, че prefix-ния ++ (++a) се връща по референция, докато
//postfix-ния ++ (a++) се връща по копие

//това идва от дефиницията на двата оператора в C++,
//която води до това, че prefix-ния може да се chain-ва,
//докато postfix-ния - не, т.е. [++++a] е валидно, но [a++++] - не

//идеята на postfix-ния е да върне старата стойност на [a], 
//а на prefix-ния - новата =>
//postfix прави копие на [a] преди да го увеличи и връща КОПИЕТО,
//prefix увеличава [a] и го връща

A& A::operator++()
{
	this->a1++;
	this->a2++;
	
	return *this; //връщаме текущия обект с НОВИТЕ му стойности  (така работи prefix-ния ++)
}

A A::operator++(int) //int се нарича dummy parameter (параметър, който не се използва)
{                    //той на практика не изпълнява никаква функционална роля освен
					 //да помогне за различаването между префиксната и постфиксната форма на оператора, т.е.
	                 //служи за отбелязка, която ни помага да различим [a++] и [++a]
	
	this->a1++;
	this->a2++;

	return A(this->a1 - 1, this->a2 - 1); //връщаме СТАРИТЕ стойности (така работи postfix-ния ++)
}

int main()
{
	A a(2, 3);

	std::cout << a++.a1 << " " << ++a.a2 << std::endl; //2 5 (първо връща старата стойност на [a1] и увеличава [a] с 1 (postfix)
	                                                   //=> имаме предвид, че [a1], [a2] се увеличават с [1] и [a2] става [4], след което
	                                                   //увеличаваме [a] още веднъж (prefix) => [a2] се увеличава с [1], става на [5]
	                                                   //и го отпечатваме


	return 0;
}
