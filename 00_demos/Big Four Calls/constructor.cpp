#include <iostream>

class A
{
public:
	A()
	{
		std::cout << "A()";
	}
};

class B
{
public:
	B()
	{
		std::cout << "B()";
	}
};

class T
{
	A a;
	A* a2;
	//A& a3;
	B b;

public:
	T() //Спрямо [t1] и [t2]:
		//влизаме в default конструктора на T, но той вижда,
	    //че има обекти от тип [A] и [B] и преди да влезем в тялото на този конструктор,
		//трябва да влезем в телата на default-ните конструктори на [A] и [B]
		//при [a2] няма да се извика, тъй като [a2] е пойнтър към обект/и от тип [A],
		//а не обект => ще се извикат конструкторите за [a] и [b], след което ще влезем в тялото
		//(напомняме, че викането става в зависимост от реда на декларация)

		//[Note] ако имахме референция, тъй като тя не може да е празна и винаги трябва да сочи към нещо,
		//трябваше да направим нов конструктор от вида
		//T(const T& refTo): a3(refTo) 
		//{
		//	//ако беше извикан с временен обект (например {}), който се създава именно чрез default-ния конструктор
		//	//ако не е извикан с временен обект, нямаше да се извика default-ния
		//}
		
	{

	    a2 = new A[3]; //помним, че при масиви винаги се вика default-ния конструкор на типа [размера] на брой пъти,
		               //тоест ще извикаме 3 пъти A()

		A arr[3]; //няма значение дали е динамичен или не, default-ния конструктор на типа се вика [размер] на брой пъти

		std::cout << "T()"; //въпреки, че викаме конструктора на [T] първи, го отпечатваме последен
	}
};

void f(T copy)
{
	T t2; //правим нова променлива от тип T (вика се default-ния на T)
}

int main()
{
	T t1; //инициализираме променлива от тип T
	
	std::cout << std::endl;
	std::cout << std::endl;

	f(t1);


	return 0;

} 
