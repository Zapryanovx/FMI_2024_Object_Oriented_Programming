#include <iostream>

class A
{
public:
	A()
	{
		std::cout << "A() ";
	}

	~A()
	{
		std::cout << "~A()";
	}

};

class B
{
public:
	B()
	{
		std::cout << "B() ";
	}

	~B()
	{
		std::cout << "~B()";
	}
};

class T
{
	A a;
	A* a2;
	B b;

public:
	T() 
	{
		std::cout << "T() ";
		//ще извика 2 пъти конструктура на A
		
		a2 = new A[2]; //в този случай трябва да освободим паметта на обекта, към който сочи [a2],
		               //тъй като класа се грижи за живота на динамичния масив,
		               //тоест ще трябва да презапишем деструктура, така че да освобождава паметта,
		               //към която [a2] сочи
	}

	~T()
	{
		delete[] a2; //освобождаваме паметта (2 пъти деструктура на A)

		std::cout << "~T()";
	}
};

void f(T other)
{
	std::cout << "----" << std::endl;

	T test;
}

int main()
{
	//вика конструкторите A() B() T() (2 пъти - за t1, t2)
	T t1; //|						 ^
	T t2; //| ред на викане на		 | ред за викане на 
	//    //| конструктури			 | деструктури
	//    //⌄						 |


	T* arr = new T[4]; //4 конструктура (видяхме защо)
	//
	////тъй като НИЕ сме отговорни за всяко динамично заделяне на памет
	////и трябва да освободим паметта, при ДИНАМИЧНО-ЗАДЕЛЕНИ обекти,
	////не се викат деструктурите 

	////освобождаваме паметта, която сме заделили с оператора delete[]

	delete[] arr; //по аналогични причини ще извика 4 деструктура

	//delete arr //ще извика един път деструктура + [!]UB[!]

  f(t1); //извиква се копиращия конструктур на T (спрямо other)
	//     //след което се създава нов обект от тип T (извикват се A() B() T())
	//	   //след края на scope-a на функцията се викат деструктурите на [other] и [test]
	//	   //съответно първо този на [test] заради дефинирания ред на триене
	//	   //и след това този на [other]
	//	   //=> функцията извиква [Копиращ конструктур за other] + [default-ния на T за test] + [Деструктур за test] + [Деструктур за other]	

	std::cout << "----" << std::endl;

	return 0;

}  //след края на ВСЕКИ scope ВИНАГИ се изтриват всички СТАТИЧНО-ЗАДЕЛЕНИ обекти
//изтриването се извършва в обратен на конструкторите ред, например [t1] ще извика
//конструкторите си в реда A() B() T() и деструктора си в реда T() B() A()
//триенето запозва отзад напред
